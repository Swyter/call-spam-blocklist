//------------------------------------------------
//--- 010 Editor v12.0 Binary Template
//
//      File: Should I Answer? DataSlice (org.mistergroup.muzutozvednout)
//   Authors: Swyter
//   Version: 2021.10.03
//   Purpose: Read the binary database format for this Android app. Contains a list of spammy phone numbers.
//            At least the deprecated app bundles a bunch of incremental database elements (see resources/assets/data_slice_*.dat)
//            Each of these is a diff that makes the app append and remove numbers from the cumulative data.
//            The app keeps an internal timestamps and retrieves an updated dataslice every now and then from a gzip'ped HTTPS file.
//            The final, processed database is stored under data/data/.../files/ratings.secdb, the format is
//            identical except the magic values start with MTZF and the CP block (that contains numbers
//            to be removed) is always empty. Because this is the absolute/processed black list thing.
//  Category: Database
// File Mask: ratings.secdb, data_slice_*.dat
//  ID Bytes: 4D 54 5A
//------------------------------------------------

char magic[4];    /* swy: DataSlice / RatingDatabase  // MTZF (file, bundled with/generated by the app), MTZD (downloaded)  // Note: MTZ is the shorthand for Můžu to zvednout? in the original Czech */
byte fmt_ver;     /* swy: 1 */
uint update_ver;  /* swy: actDB, newDB (maybe the app version used to generate it or something) */

char ww[2];       /* swy: magic value: WW */
uint eleven_zero; /* swy: don't ask me */

uint added_item_count;
struct
{
    uint64 tlf;
    ubyte positive, negative, neutral, unk_zero_padding_maybe; /* swy: seems like there's an extra byte for alignment, there are three fields for each telephone number's ratings/user reports, see the Web for the SEO-friendly version of this, the app uses crowdsourcing to fill the database */

    /* swy: Telemarketer: 1, Silent call: 3, Scam call: 10, Unsolicited: 5, Non-profit: 8, Nuisance: 16, Robocall: 18 */
    enum <ubyte>
    {
        cat_choose_category  =  0, /*  0-Choose category         */
        cat_telemarketer     =  1, /*  1-Telemarketer            */
        cat_debt_collector   =  2, /*  2-Debt collector          */
        cat_silent_call      =  3, /*  3-Silent call             */
        cat_nuisance_call    =  4, /*  4-Nuisance call           */
        cat_unsolicited_call =  5, /*  5-Unsolicited call        */
        cat_call_centre      =  6, /*  6-Call centre             */
        cat_fax_machine      =  7, /*  7-Fax machine             */
        cat_non_profit_org   =  8, /*  8-Non-profit Organization */
        cat_political_call   =  9, /*  9-Political call          */
        cat_scam_call        = 10, /* 10-Scam call               */
        cat_prank_call       = 11, /* 11-Prank call              */
        cat_sms              = 12, /* 12-SMS                     */
        cat_survey           = 13, /* 13-Survey                  */
        cat_other            = 14, /* 14-Other                   */
        cat_finance_service  = 15, /* 15-Financial Service       */
        cat_company          = 16, /* 16-Company                 */
        cat_service          = 17, /* 17-Service                 */
        cat_robocall         = 18, /* 18-Robocall                */
    } category <bgcolor=cBlue>;

} item[added_item_count];

char cp[2]; /* swy: magic value: CP */
uint deleted_item_count;
struct
{
    uint64 tlf;
} deleted_item[deleted_item_count];

char end[6];  /* swy: magic value: MTZEND */

/* -- */

local uint i = 0;
local string buf ="", cur;
for (i=0; i<added_item_count; i++)
{
    //if (1)//(item[i].negative > 1)// && item[i].negative > item[i].positive && item[i].negative >= item[i].neutral)
    if (item[i].negative > 1 && item[i].negative > item[i].positive && item[i].negative > item[i].neutral)
    {
        cur = ""; SPrintf(cur, "+%Lu\n", item[i].tlf);
        buf += cur;
    }
}

Printf(buf);